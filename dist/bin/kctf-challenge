#!/bin/bash
# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
function has_cluster_config {
  [[ ! -z "${CLUSTER_NAME-}" ]]
}

function require_cluster_config {
  if ! has_cluster_config; then
    echo "No config loaded. You need to run \"kctf config\" first." >&2
    exit 1
  fi
}

function infer_challenge_name {
  if [[ -z "${CHALLENGE_NAME-}" ]]; then
    CHALLENGE_NAME=$(realpath "${PWD}" --relative-to "${KCTF_CTF_DIR}" | cut -d/ -f1)
  fi

  CHALLENGE_DIR="${KCTF_CTF_DIR}/${CHALLENGE_NAME}"
  if [[ -z "${CHALLENGE_NAME-}" ]] || [[ "${CHALLENGE_NAME}" == . ]] || [[ "${CHALLENGE_NAME}" == ".." ]] || [[ ! -e "${CHALLENGE_DIR}/challenge.yaml" ]]; then
    echo "Couldn't find challenge.yaml under \"${CHALLENGE_DIR}\"" >&2
    echo "You need to be inside a challenge directory or set --challenge-name" >&2
    exit 1
  fi

  # the actual challenge name is in the challenge.yaml
  #CHALLENGE_NAME=$("${KCTF_BIN}/yq" eval ".metadata.name" "${CHALLENGE_DIR}/challenge.yaml")
}

function parse_help_arg_only_usage {
  echo -e "usage: kctf chal ${COMMAND} [args]" >&2
  echo -e "" >&2
  echo -e "${DESCRIPTION}" >&2
  echo -e "" >&2
  echo -e "Args:" >&2
  echo -e "  -h|--help        print this help" >&2
}

function parse_help_arg_only {
  OPTS="h"
  LONGOPTS="help"
  PARSED=$(getopt --options=$OPTS --longoptions=$LONGOPTS --name "kctf chal create" -- "$@")
  if [[ $? -ne 0 ]]; then
    parse_help_arg_only_usage
    exit 1
  fi
  eval set -- "$PARSED"

  CHALLENGE_NAME=
  while true; do
    case "$1" in
      -h|--help)
        parse_help_arg_only_usage
        exit 0
        ;;
      --)
        shift
        break
        ;;
      *)
        echo "Unrecognized argument \"$1\"." >&2
        parse_help_arg_only_usage
        exit 1
        ;;
    esac
  done

  infer_challenge_name || return
}

function parse_container_name_usage {
  echo -e "usage: kctf chal ${COMMAND} [args]" >&2
  echo -e "  -h|--help        print this help" >&2
  echo -e "  --container      name of the container to interact with, e.g. challenge (default) or healthcheck" >&2
}

function parse_container_name {
  OPTS="h"
  LONGOPTS="help,container:"
  PARSED=$(getopt --options=$OPTS --longoptions=$LONGOPTS --name "kctf chal create" -- "$@")
  if [[ $? -ne 0 ]]; then
    parse_container_name_usage
    exit 1
  fi
  eval set -- "$PARSED"

  CHALLENGE_NAME=
  CONTAINER="challenge"
  while true; do
    case "$1" in
      -h|--help)
        parse_container_name_usage
        exit 0
        ;;
      --container)
        CONTAINER="$2"
        shift 2
        ;;
      --)
        shift
        break
        ;;
      *)
        echo "Unrecognized argument \"$1\"." >&2
        parse_container_name_usage
        exit 1
        ;;
    esac
  done

  infer_challenge_name || return
}

function build_image {
  # build the image
  CONTAINER_NAME="$1"
  CONTAINER_DIR="${CHALLENGE_DIR}/${CONTAINER_NAME}"
  echo "building image in \"${CONTAINER_DIR}\""
  make -C "${CONTAINER_DIR}" .gen/docker-image || return
  IMAGE_ID=$(cat "${CONTAINER_DIR}/.gen/docker-image")
  if [[ $? -ne 0 ]]; then
    return 1
  fi

  # strip optional sha256 prefix
  if [[ "${IMAGE_ID}" = sha256:* ]]; then
    IMAGE_ID=$(echo "${IMAGE_ID}" | cut -d ':' -f 2)
  fi
  echo "Image ID \"${IMAGE_ID}\""
}

function healthcheck_enabled {
  [[ $("${KCTF_BIN}/yq" eval '.spec.healthcheck.enabled' "${CHALLENGE_DIR}/challenge.yaml") == "true" ]]
}

function build_images {
  build_image challenge || return
  CHALLENGE_IMAGE_LOCAL="${IMAGE_ID}"
  if healthcheck_enabled; then
    build_image healthcheck || return
    HEALTHCHECK_IMAGE_LOCAL="${IMAGE_ID}"
  fi
}

function push_image {
  IMAGE_BASE_URL=$1
  IMAGE_ID=$2

  #if the image id is a full URL, it has been already pushed
  if [[ "${IMAGE_ID}" = "${IMAGE_BASE_URL}:"* ]]; then
    IMAGE_URL="${IMAGE_ID}"
  else
    IMAGE_URL="${IMAGE_BASE_URL}:${IMAGE_ID}"
    docker tag "${IMAGE_ID}" "${IMAGE_URL}" || return
    docker push "${IMAGE_URL}" || return
  fi
  echo "Image pushed to \"${IMAGE_URL}\""
}

function push_images {
  push_image "${REGISTRY}/${PROJECT}/${CHALLENGE_NAME}-challenge" "${CHALLENGE_IMAGE_LOCAL}" || return
  CHALLENGE_IMAGE_REMOTE="${IMAGE_URL}"
  if healthcheck_enabled; then
    push_image "${REGISTRY}/${PROJECT}/${CHALLENGE_NAME}-healthcheck" "${HEALTHCHECK_IMAGE_LOCAL}" || return
    HEALTHCHECK_IMAGE_REMOTE="${IMAGE_URL}"
  fi
}

function kctf_chal_start {
  require_cluster_config
  COMMAND="start" DESCRIPTION="Deploy the challenge to the cluster." parse_help_arg_only $@ || return
  build_images || return
  push_images || return

  # update challenge.yaml with the image urls
  "${KCTF_BIN}/yq" eval ".spec.image = \"${CHALLENGE_IMAGE_REMOTE}\"" --inplace "${CHALLENGE_DIR}/challenge.yaml"
  if healthcheck_enabled; then
    "${KCTF_BIN}/yq" eval ".spec.healthcheck.image = \"${HEALTHCHECK_IMAGE_REMOTE}\"" --inplace "${CHALLENGE_DIR}/challenge.yaml"
  fi

  kubectl apply -f "${CHALLENGE_DIR}/challenge.yaml" || return
}

function kctf_chal_stop {
  require_cluster_config
  COMMAND="stop" DESCRIPTION="Stop a challenge running on the cluster." parse_help_arg_only $@ || return
  kubectl delete -f "${CHALLENGE_DIR}/challenge.yaml" || return
}

function kctf_chal_status {
  require_cluster_config
  COMMAND="status" DESCRIPTION="Print the challenge status." parse_help_arg_only $@ || return

  echo "= CHALLENGE RESOURCE ="
  echo
  kubectl get "challenge/${CHALLENGE_NAME}"
  echo
  echo "= INSTANCES / PODs ="
  echo
  echo "Challenge execution status"
  echo "This shows you how many instances of the challenges are running."
  echo
  kubectl get pods -l "app=${CHALLENGE_NAME}" -o wide
  echo
  echo
  echo "= DEPLOYMENTS ="
  echo
  echo "Challenge deployment status"
  echo "This shows you if the challenge was deployed to the cluster."
  echo
  kubectl get deployments -l "app=${CHALLENGE_NAME}" -o wide
  echo
  echo "= EXTERNAL SERVICES ="
  echo
  echo "Challenge external status"
  echo "This shows you if the challenge is exposed externally."
  echo
  kubectl get services -l "app=${CHALLENGE_NAME}" -o wide
  kubectl get ingress -l "app=${CHALLENGE_NAME}" -o wide
}

function kctf_chal_debug_logs {
  require_cluster_config
  COMMAND="debug logs" parse_container_name $@ || return

  kubectl logs -l "app=${CHALLENGE_NAME}" -c "${CONTAINER}"
}

function kctf_chal_debug_ssh {
  require_cluster_config
  COMMAND="debug ssh" parse_container_name $@ || return

  kubectl exec "deployment/${CHALLENGE_NAME}" -c "${CONTAINER}" -it -- /bin/bash
}

function kctf_chal_debug_port_forward_usage {
  echo -e "usage: kctf chal debug port-forward [args]" >&2
  echo -e "args:" >&2
  echo -e "  -h|--help     print this help" >&2
  echo -e "  --port:       port in the challenge to connect to (default 1337)" >&2
  echo -e "  --local-port: local port to listen on (defaults to random free port)" >&2
}

function kctf_chal_debug_port_forward {
  REMOTE_PORT=1337
  LOCAL_PORT=""
  CHALLENGE_NAME=

  OPTS="h"
  LONGOPTS="help,challenge-name:,port:,local-port:"
  PARSED=$(getopt --options=$OPTS --longoptions=$LONGOPTS --name "kctf chal create" -- "$@")
  if [[ $? -ne 0 ]]; then
    kctf_chal_debug_port_forward_usage
    exit 1
  fi
  eval set -- "$PARSED"

  CHALLENGE_NAME=
  while true; do
    case "$1" in
      -h|--help)
        kctf_chal_debug_port_forward_usage
        exit 0
        ;;
      --port)
        REMOTE_PORT="$2"
        shift 2
        ;;
      --local-port)
        LOCAL_PORT="$2"
        shift 2
        ;;
      --)
        shift
        break
        ;;
      *)
        echo "Unrecognized argument \"$1\"." >&2
        kctf_chal_debug_port_forward_usage
        exit 1
        ;;
    esac
  done

  infer_challenge_name || return

  echo 'starting port-forward, ctrl+c to exit'
  kubectl port-forward "deployment/${CHALLENGE_NAME}" --address=127.0.0.1 "${LOCAL_PORT}:${REMOTE_PORT}"
}

function kctf_chal_debug_docker {
  COMMAND="debug docker" parse_container_name $@ || return

  build_image "${CONTAINER}" || return

  DOCKER_NAME="kctf-${KCTF_CTF_NAME}-${CHALLENGE_NAME}-${CONTAINER}"

  # kill any existing containers
  docker kill "${DOCKER_NAME}" >/dev/null 2>/dev/null
  docker container rm "${DOCKER_NAME}" >/dev/null 2>/dev/null

  echo "Running docker container ${IMAGE_ID} using name ${DOCKER_NAME}"
  docker run -d --name "${DOCKER_NAME}" -it -p 1337 --privileged "${IMAGE_ID}" || return 1
  docker ps -f "name=${DOCKER_NAME}" || return 1
  echo "Container running, ctrl+c to exit"
  docker attach "${DOCKER_NAME}"
}


function kctf_chal_debug_usage {
  echo -e "usage: kctf chal debug command" >&2
  echo -e "available commands:" >&2
  echo -e "  logs:         print logs of the container" >&2
  echo -e "  ssh:          spawn an interactive bash in the container" >&2
  echo -e "  port-forward: create a port-forward to the container's default port" >&2
  echo -e "  docker:       run the docker container locally" >&2
  echo -e "NOTE: you can use --container=healthcheck flag to debug the healthcheck" >&2
}

function kctf_chal_debug {
  if [[ $# -lt 1 ]]; then
    echo "unexpected argument count" >&2
    kctf_chal_debug_usage
    exit 1
  fi

  case "$1" in
    -h|--help)
      kctf_chal_debug_usage
      exit 0
      ;;
    logs)
      shift
      kctf_chal_debug_logs $@
      ;;
    ssh)
      shift
      kctf_chal_debug_ssh $@
      ;;
    port-forward)
      shift
      kctf_chal_debug_port_forward $@
      ;;
    docker)
      shift
      kctf_chal_debug_docker $@
      ;;
    *)
      echo "unknown command" >&2
      kctf_chal_debug_usage
      exit 1
      ;;
  esac
}

function kctf_chal_create_usage {
  echo "usage: kctf chal create name" >&2
}

function kctf_chal_create {
  if [[ $# -ne 1 ]]; then
    echo "kctf chal create: name missing" >&2
    kctf_chal_create_usage
    exit 1
  fi

  if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    kctf_chal_create_usage
    exit 0
  fi

  CHALLENGE_NAME="$1"
  shift

  CHALLENGE_DIR="${KCTF_CTF_DIR}/${CHALLENGE_NAME}"
  if [[ -e "${CHALLENGE_DIR}" ]]; then
    exit 1
  fi

  umask a+rx
  cp -p -r "${KCTF_CTF_DIR}/kctf/challenge-templates/challenge-skeleton" "${CHALLENGE_DIR}"
  ${KCTF_BIN}/yq eval ".metadata.name = \"${CHALLENGE_NAME}\"" --inplace "${CHALLENGE_DIR}/challenge.yaml"
}

function kctf_chal_list {
  echo '== challenges in repository =='
  for dir in ${KCTF_CTF_DIR}/*; do
    if [[ "$(basename ${dir})" == "kctf" ]]; then
      continue
    fi
    if [[ ! -e "${dir}/challenge.yaml" ]]; then
      continue
    fi
    ${KCTF_BIN}/yq eval ".metadata.name" "${dir}/challenge.yaml"
  done
  if has_cluster_config; then
    echo '== deployed challenges =='
    kubectl get challenges
  fi
}

function kctf_chal_usage {
  echo -e "usage: kctf chal command" >&2
  echo -e "available commands:" >&2
  echo -e "  create: create a new challenge from a template" >&2
  echo -e "  list:   list existing challenges" >&2
  echo -e "  start:  deploy the challenge to the cluster" >&2
  echo -e "  stop:   delete the challenge from the cluster" >&2
  echo -e "  status: print the current status of the challenge" >&2
  echo -e "  debug:  commands for debugging the challenge" >&2
}

if [[ $# -lt 1 ]]; then
  echo "unexpected argument count" >&2
  kctf_chal_usage
  exit 1
fi

case "$1" in
  -h|--help)
    kctf_chal_usage
    exit 0
    ;;
  create)
    shift
    kctf_chal_create $@
    ;;
  list)
    shift
    kctf_chal_list $@
    ;;
  start)
    shift
    kctf_chal_start $@
    ;;
  stop)
    shift
    kctf_chal_stop $@
    ;;
  status)
    shift
    kctf_chal_status $@
    ;;
  debug)
    shift
    kctf_chal_debug $@
    ;;
  *)
    echo "unknown command" >&2
    kctf_chal_usage
    exit 1
    ;;
esac

